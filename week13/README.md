## [LongSubSequence (가장 긴 감소하는 부분 수열)](https://www.acmicpc.net/problem/11722)

문제요약
> 수열이 주어졌을 때, 감소하는 부분 수열 중 가장 긴 수열을 찾아라
>> ex) [10 ,30 ,10, 20, 20, 10] => [30, 20, 10] => length: 3

#### D.P (Dynamic Programming)  
>이전의 결과를 바탕으로 현재의 값을 구한다.

DP 문제의 경우, DP 문제라는 것을 판별하는 것이 일단 가장 중요하다고 생각한다.
DP 와 브루트 포스의 차이를 이해하는 것이 관건.

브루트 포스의 경우 단순히 차례대로 앞에서 부터 __계산하며__ 결과를 도출 할 수 있다.
DP 의 경우 모든 경우의 수를 전부 고려해 봐야 한다. 

[RGB 거리](https://www.acmicpc.net/problem/1149)  
위 문제를 풀어보면 '브루트 포스'와 'DP'의 차이를 느낄 수 있다.

DP 는 점화식으로 점철되어지는 경우가 많고, 점화식만 잘 찾아내면 쉽게 풀 수 있다.
  
~~알고리즘 테스트에서 많이 나오진 않는듯 하다~~

하지만 DP는 그 접근법을 모르면 풀지 못하거나, '메모리' 혹은 '시간' 초과가 발생할 여지가 많아서 정리한다.

풀이
~~~
우선, 이게 DP 문제인지 파악하는 것이 중요하다.

문제를 다시 보자 '수열이 주어졌을 때, 감소하는 부분 수열 중 가장 긴 수열을 찾아라'
[10, 30, 10, 20, 20, 10]

첫번째 인덱스의 값 '10'을 보았을 때, 그 뒤로 '10' 보다 작은 수가 없으므로 감소하는 수열은 [10] 으로 끝난다.
두번째 인덱스의 값 '30'을 보면, [30, 20, 10] 으로 감소하는 수열을 찾을 수 있다. 

우리 뇌는 다방면으로 생각할 수 있지만, 연산은 느리다.
하지만, 컴퓨터는 순차적으로 계산하지만 연산은 빠르다.

순차적으로 [30, 20, 10] 을 찾아보자.
두번째 인덱스의 값 '30' 부터 시작하기 때문에, '30' 이후의 값을 살펴보면 된다. 
'30' 이후의 '10'(세번째 인덱스의 값)은 '30' 보다 작기 때문에, 감소하는 부분 수열을 만족한다. -> [30, 10]

'10' 이 후에 감소하는 부분 수열을 찾기 위해서 보면 '10' 보다 작은 수가 없기 때문에 -> [30, 10] 으로 마무리 된다.
(이런 부분이 DP와 브루트 포스의 교착점이 된다)

다시 생각해보자
우리는 [30, 20, 10]을 기대하고 있는데, [30, 10]이 출력된다.
다시 두번째 인덱스의 값 '30' 으로 돌아간다. '30' 이후의 수열에서, '30' 보단 작은 최대값을 찾는다.
네번째 인덱스의 값 '20'을 찾았다. '20' 이후의 수열에서, '20' 보다 작은 최대값을 찾는다.

이렇게 세번째 인덱스의 값을 시작으로 하고, 'N - 1' 번째까지 진행한다.
부분 수열을 찾을 때 마다 최대값 탐색을 해야한다. 수열이 6개가 아닌 600개가 주어지고, 각 인덱스 마다, 또 해당 인덱스의 부분 수열 마다 탐색을 해야한다.
시간이 어마어마하게 걸릴 것이다.

다른 방법이 필요하다.
* 이 부분을 생각하기가 정말 어렵다.

위에서 브루트 포스와의 교착점을 느꼈을 때, DP 문제로 전환해서 생각해 보는 힘을 기르는게 중요하다.

다시 DP 의 정의를 생각해보자, 
'이 전의 값를 바탕으로 현재의 값을 찾는다'

여기서 '이 전의 값'을 이용하려면 어떻게 해야 할까?
우리는 인덱스 순서대로 기준을 잡고 이 후의 수열에 집중했다.

방법을 바꿔, '현재 인덱스의 값'이 마지막이라고 생각할 경우의 부분수열을 생각해보자.

1. 첫번째 인덱스의 값 '10'을 수열의 마지막이라고 생각하고 부분수열을 생각했을 때, [10] 이므로 결과는 '1'

2. 두번째 인덱스의 값 '30'을 수열의 마지막 이라고 생각했을 때 [10, 30] 에서 감소하는 부분 수열은 첫번째 인덱스의 값부터 봤을 때, 
'현재 인덱스의 값(30)' 보다 '큰' 값이 없으므로 [30] 이 부분 수열이다. 결과는 '1'

3. 세번째 인덱스의 값 '10'을 수열의 마지막이라고 생각하면, [10, 30, 10]이고 여기서 감소하는 부분 수열 중 '10' 보다 값 중에 가장 긴 부분 수열을 이루는 '값'은 '30' 이 가지고 있다.
'30'의 결과는 '1' 이고 '현재 인덱스의 값'에서 디폴트로 자기 자신을 부분 수열로 할 수 있으므로 '30'의 결과에 자기 자신을 부분 수열로 했을 때의 결과 '1'을 더한 '2' 가 결과가 된다.

4. 네번째 인덱스의 값 '20'으로 해보자. [10, 30, 10, 20]이고 첫번째 인덱스의 값과 '현재 인덱스의 값'을 보면서 큰 값이 있는지 찾는다.
'10'은 작으니 안되고, '30'은 된다. '30'의 결과값은 1 이고 자기 자신 '20'을 부분 수열로 했을 때의 결과 '1'을 더하면 결과는 '2'
이후의 '10'은 '20'보다 작으니 고려할 필요가 없다.

5. 넘어가서 마지막 인덱스를 해보자, 마지막 인덱스의 값 '10'이고 [10, 30, 10, 20, 20, 10] 일 때, '30'이 가능하다.
또 네번째 인덱스의 값(20)이 가능하다. '20'의 결과 값은 '2' 이고 이 결과값에 현재 인덱스의 결과값(1)을 포함한 '3' 이 결과값이 된다.
결과적으로 '3'은 다섯번째 인덱스의 결과값 '2'에 현재 인덱스의 결과값 '1'을 더한 '3'이 되는 것을 알 수 있다.

이렇게 이전의 결과값을 통해서 현재의 결과를 도출해내는 방법으로 문제를 풀 수 있다. 
~~~

유형
* DP