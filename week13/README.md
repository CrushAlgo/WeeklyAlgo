## LongSubSequence [(가장 긴 감소하는 부분 수열)](https://www.acmicpc.net/problem/11722)

문제요약
> 수열이 주어졌을 때, 감소하는 부분 수열 중 가장 긴 수열을 찾아라
>> ex) [10 ,30 ,10, 20, 20, 10] => [30, 20, 10] => length: 3

* D.P (Dynamic Programming)  
>이전의 결과를 바탕으로 현재의 값을 구한다.

DP 문제의 경우, DP 문제라는 것을 판별하는 것이 일단 가장 중요하다고 생각한다.
DP 와 브루트 포스의 차이를 이해하는 것이 관건.

브루트 포스의 경우 단순히 차례대로 앞에서 부터 __계산하며__ 결과를 도출 할 수 있다.
DP 의 경우 모든 경우의 수를 전부 고려해 봐야 한다. 

[RGB 거리](https://www.acmicpc.net/problem/1149)  
위 문제를 풀어보면 '브루트 포스'와 'DP'의 차이를 느낄 수 있다.

DP 는 점화식으로 점철되어지는 경우가 많고, 점화식만 잘 찾아내면 쉽게 풀 수 있다.
  
~~알고리즘 테스트에서 많이 나오진 않는듯 하다~~

하지만 DP는 그 접근법을 모르면 풀지 못하거나, '메모리' 혹은 '시간' 초과가 발생할 여지가 많아서 정리한다.

풀이
~~~
우선, 이게 DP 문제인지 파악하는 것이 중요하다.

문제를 다시 보자 '수열이 주어졌을 때, 감소하는 부분 수열 중 가장 긴 수열을 찾아라'
[10, 30, 10, 20, 20, 10]

첫번째 인덱스의 값 '10'을 보았을 때, 그 뒤로 '10' 보다 작은 수가 없으므로 감소하는 수열은 [10] 으로 끝난다.
두번째 인덱스의 값 '30'을 보면, [30, 20, 10] 으로 감소하는 수열을 찾을 수 있다. 

우리 뇌는 다방면으로 생각할 수 있지만, 연산은 느리다.
하지만, 컴퓨터는 순차적으로 계산하지만 연산은 빠르다.

순차적으로 [30, 20, 10] 을 찾아보자.
두번째 인덱스의 값 '30' 부터 시작하기 때문에, '30' 이후의 값을 살펴보면 된다. 
'30' 이후의 '10'(세번째 인덱스의 값)은 '30' 보다 작기 때문에, 감소하는 부분 수열을 만족한다. -> [30, 10]

'10' 이 후에 감소하는 부분 수열을 찾기 위해서 보면 '10' 보다 작은 수가 없기 때문에 -> [30, 10] 으로 마무리 된다.
(이런 부분이 DP와 브루트 포스의 교착점이 된다)

다시 생각해보자
우리는 [30, 20, 10]을 기대하고 있는데, [30, 10]이 출력된다.
다시 두번째 인덱스의 값 '30' 으로 돌아간다. '30' 이후의 수열에서, '30' 보단 작은 최대값을 찾는다.
네번째 인덱스의 값 '20'을 찾았다. '20' 이후의 수열에서, '20' 보다 작은 최대값을 찾는다.

이렇게 세번째 인덱스의 값을 시작으로 하고, 'N - 1' 번째까지 진행한다.
부분 수열을 찾을 때 마다 최대값 탐색을 해야한다. 수열이 6개가 아닌 600개가 주어지고, 각 인덱스 마다, 또 해당 인덱스의 부분 수열 마다 탐색을 해야한다.
시간이 어마어마하게 걸릴 것이다.

다른 방법이 필요하다.
* 이 부분을 생각하기가 정말 어렵다.

위에서 브루트 포스와의 교착점을 느꼈을 때, DP 문제로 전환해서 생각해 보는 힘을 기르는게 중요하다.

다시 DP 의 정의를 생각해보자, 
'이 전의 값를 바탕으로 현재의 값을 찾는다'

여기서 '이 전의 값'을 이용하려면 어떻게 해야 할까?
우리는 인덱스 순서대로 기준을 잡고 이 후의 수열에 집중했다.

방법을 바꿔, '현재 인덱스의 값'이 마지막이라고 생각할 경우의 부분수열을 생각해보자.

1. 첫번째 인덱스의 값 '10'을 수열의 마지막이라고 생각하고 부분수열을 생각했을 때, [10] 이므로 결과는 '1'

2. 두번째 인덱스의 값 '30'을 수열의 마지막 이라고 생각했을 때 [10, 30] 에서 감소하는 부분 수열은 첫번째 인덱스의 값부터 봤을 때, 
'현재 인덱스의 값(30)' 보다 '큰' 값이 없으므로 [30] 이 부분 수열이다. 결과는 '1'

3. 세번째 인덱스의 값 '10'을 수열의 마지막이라고 생각하면, [10, 30, 10]이고 여기서 감소하는 부분 수열 중 '10' 보다 값 중에 가장 긴 부분 수열을 이루는 '값'은 '30' 이 가지고 있다.
'30'의 결과는 '1' 이고 '현재 인덱스의 값'에서 디폴트로 자기 자신을 부분 수열로 할 수 있으므로 '30'의 결과에 자기 자신을 부분 수열로 했을 때의 결과 '1'을 더한 '2' 가 결과가 된다.

4. 네번째 인덱스의 값 '20'으로 해보자. [10, 30, 10, 20]이고 첫번째 인덱스의 값과 '현재 인덱스의 값'을 보면서 큰 값이 있는지 찾는다.
'10'은 작으니 안되고, '30'은 된다. '30'의 결과값은 1 이고 자기 자신 '20'을 부분 수열로 했을 때의 결과 '1'을 더하면 결과는 '2'
이후의 '10'은 '20'보다 작으니 고려할 필요가 없다.

5. 넘어가서 마지막 인덱스를 해보자, 마지막 인덱스의 값 '10'이고 [10, 30, 10, 20, 20, 10] 일 때, '30'이 가능하다.
또 네번째 인덱스의 값(20)이 가능하다. '20'의 결과 값은 '2' 이고 이 결과값에 현재 인덱스의 결과값(1)을 포함한 '3' 이 결과값이 된다.
결과적으로 '3'은 다섯번째 인덱스의 결과값 '2'에 현재 인덱스의 결과값 '1'을 더한 '3'이 되는 것을 알 수 있다.

이렇게 이전의 결과값을 통해서 현재의 결과를 도출해내는 방법으로 문제를 풀 수 있다. 
~~~

유형
* DP

---

## RGBDistance [(RGB 거리)](https://www.acmicpc.net/problem/1149)

#### 1. 문제 요약
> 미국 베버리힐즈를 생각해 보자. 집들이 쭈욱 늘어서 있다. 집집마다 색을 칠 할 수 있는데, 각 집마다 색을 칠하는 비용이 다르다.
조건이 주어질 때, 비용이 최소가 되도록 하라.
>> 1. 색은 Red, Green, Blue 3가지 색상으로 칠 할 수 있다.
>> 2. 이웃 집과 색이 같으면 안된다. 집 [1, 2, 3] 이 있다고 할 때, [R, G, R] / [G, B, R] ... 등으로 칠해져야 한다.
>> 3. 입력으로 집의 갯수와 각 집에 색을 칠했을 때, 발생하는 비용이 차례대로 주어진다. (위에 링크 참조)  

#### 2. 풀이
> 처음에는 각 집에 색을 칠 했을 때 최소 비용을 구하고, 그 색을 기준으로 다음 집의 색을 결정한 후에 최솟값을 찾아 갔다.

~~~
첫번째 집에 R, G, B 색상을 칠했을 때 비용이 [10, 20, 30] 순이라면, 색은 'Red' 가 되겠다.
두번째 집에 비용이 [20, 10, 30] 이라면, 일단 이웃한 색을 칠하면 안되니 
'20'(Red)을 제외하고 '10'(Green), '30'(Blue) 중 최솟값을 구하는 식으로 풀었다.
~~~

해당 예 에서는 문제가 없어보인다. 조금만 더 생각해보면 문제가 발생하는 것을 알 수 있다.

~~~
첫번째 집 [50, 60, 70]
두번째 집 [1, 999, 999]

라고 생각해 보면 첫번째 집에서 '50'(Red) 를 택한다. 두번째 집에서는 '999'(Green & Blue) 를 택하게 되고 결과는 참담해진다.
정답은 '60'(Green)' + '1'(Red) 가 되야 함을 알 수 있다.
~~~

> 여기서, DP 문제라는 것을 눈치 채야 한다.  

_주어지는 모든 경우의 수에 대해 따져보고, 앞의 결과가 뒤에 결과에 영향을 미치는 문제_

~~~
각 경우의 수에 대한 결과값을 끝까지 가져가야 한다.

문제에서는 첫번째 집에서 칠한 색의 결과를 두번째 집에서도 이용해야하고 마지막 집에 갈 때 까지 가져가야 한다.

따라서, 순서대로 진행하되 해당 집까지의 최소 비용을 구하면서 진행한다. 
(주어지는 N 이 '5'라면, 1번째 집까지의 최소비용, 2번째 집까지의 최소비용을 알고 있어야 한다)

# 또한 조건이 주어지므로 조건을 고려하여 최소비용을 계산해야한다.
~~~

#### 3. 유형 
* DP

