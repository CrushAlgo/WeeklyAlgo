## BinarySearchTree (이진 검색 트리) / ~~FAIL, runtime error~~
https://www.acmicpc.net/problem/5639

* 이진 트리  
: 트리의 모든 노드가 왼쪽 자식 노드와 오른쪽 자식 노드 만을 가지도 록 함으로써 트리의 차수가 2 이하가 되도록 제한한 트리
    * 특성  
    : 노드 수가 'N' 인 이진 트리의 간선 수는 'N-1' (단, 공백 이진 트리는 제외)  
    : 높이가 'h'인 이진 트리가 가질 수 있는 노드 수는 '(h+1) ~ (2^h+1 -1)'

    * 구현 방법  
        * 1차원 배열을 이용한 이진 트리 구현  
        : 높이가 'h'인 '포화 이진 트리'의 노드 번호를 배열의 인덱스로 사용.  
        : 트리의 높이에 따라, 노드의 갯수가 정해져 있기 때문에, 수식을 통해 파악 가능.
        : 편향 이진 트리일 경우, 메모리 낭비 심하고 트리 높이가 동적으로 변할 경우, 크기 변경이 어렵다.  
        
        * 연결 자료 구조  
        : 이진 트리의 모든 노드는 2개의 자식 노드를 갖으므로, 좌, 우 노드의 주소를 저장 할 수있는 노드를 만들면 된다.

문제 요약
> 트리를 전위 순회한 결과가 주어지면, 이를 후위 순회한 결과로 한 줄에 하나씩 출력해라.

풀이
~~~
연결 자료 구조로 노드 구현.
~~~

분류
* 트리
* 자료구조

***

## Calendar (2007)
https://www.acmicpc.net/problem/1924

문제 요약
> 2007년 달력에서 주어지는 '월', '일'을 가지고 '요일'을 알아내라.
>> 1. 1월 1일은 월요일.
>> 2. '1,3,5,7,8,10,12월'은  31일 까지, '4,6,9,11월'은 30일 '2월'은 28일 까지.

풀이
~~~
날짜(일)을 7로 나눈 나머지는 '0~6'까지의 주기를 띈다.
각 달에 해당하는 날짜를 더해주면서 합한 일수를 7로 나누면 요일이 나온다.
~~~

랩업

___List Initializing (java)___

`List<Object> fixList = Arrays.asList('obj1', 'obj2', ...);`
> 초기화를 해버려서 list 고정된다.

`List<Object> changeableList = new ArraysList<>(Arrays.asList('obj1', 'obj2', ...));`
> 변경 가능한 list.

`List<Object> list = new ArrayList<>();`
`Collections.addAll(list, 'obj1', 'obj2', ...);`
> Collections 사용

`List<Object> streamList = Stream.of('obj1', 'obj2', ...).collect(Collectors.toList());`  
`ArrayList<Object> places = Stream.of('obj1', 'obj2', ...).collect(Collectors.toCollection(ArrayList::new));`
> Stream 사용

분류
* 구현

***

## ClimbingStair (계단 오르기), ~~FAIL, runtime error~~

>동적 계획법 (DP)
~~~
동적 계획법의 원리는 매우 간단하다. 일반적으로 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달하는 것이다. 
각 하위 문제의 해결을 계산한 뒤, 그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다.  

* 동적계획법은 계산 횟수를 줄일 수 있다.
* 하위 문제의 수가 기하 급수적으로 증가할 때 유용하다.
* '최단 경로 문제', '행렬의 제곱 문제' 등의 최적화에 사용.
* 문제를 해결하기 위한 모든 방법을 검토하고, 최적의 풀이법을 찾아낸다.
* 가능한 모든 방법을 충분히 빠른 속도로 처리할 수 있는 경우, 동적 계획법은 최적의 해법.
~~~

문제 요약
> 계단 마다 점수가 매겨져있다. 특정 조건으로 계단을 밟아 올라갈 때, 밟은 계단의 합이 가장 큰 값을 리턴하라.
>> 1. 계단을 한칸 혹은 두칸씩 올라갈 수 있다.
>> 2. 세칸 이상 연속으로 계단을 올라 갈 수 없다.
>> 3. 마지막 계단은 꼭 밟아야 한다.  

풀이
~~~
현재 서 있는 칸까지의 최대 값을 생각해 봤을 때, 두가지 경우의 수가 발생한다.  
1. 전칸을 밝고 현재 칸을 밟는 경우.
2. 전전 칸을 밟고 현재 칸을 밟는 경우.  

근데, 세 칸을 연속으로 밟을 수 없기 때문에, '1'의 경우 조건을 추가해 줘야한다.  
세 칸을 연속으로 밟지 않으려면, 현재칸, 전칸, 전전전칸을 밟아야한다. (cf, 전전칸, 이걸 밟으면 안됨)  
따라서, 위의 '1'의 경우에 조건을 추가한다.  

1. '전전전칸을 밟고' + 전칸을 밟고 현재 칸을 밟는 경우.
~~~

분류
* DP

***

## SafeZone (안전 영역)
https://www.acmicpc.net/problem/2468

문제 요약
> 구역이 정방 행렬로 주어지고, 각 구역의 요소들은 건물의 높이이며, 건물 높이는 서로 다르다. 이 구역에 비가 내릴 때, 침수되는 건물이 발생한다.  
침수 되지 않은 '안전 영역'은 침수 되지 않은 건물 상,하,좌,우로 연결된 구역을 하나의 안전 지역으로 볼 때, 안전 구역이 가장 많이 생기는 강수량을 구하라.
>> ~~문제 이해하기 어려웠다.~~
>> 1. 2차원 배열상에 건물 높이는 서로 다르게 주어진다.
>> 2. 강수량에 영향을 받는 것은 가장 낮은 건물 높이 부터, 가장 높은 건물 높이까지 일 것이다.
>> 3. 주변(상,하,좌,우)이 다 침수되고 건물 하나만 남아있어도 '안전 구역' 으로 카운트 한다.
>> 4. 주변에 침수되지 않은 건물이 있으면 연결해서 하나의 '안전 구역'으로 카운트 한다.    
>> 5. __비가 오지 않는 경우도 있다.__

풀이
~~~
건물 높이를 입력받을 때, 최대, 최소 건물의 높이를 받아놓고, 강수량을 설정한다.  
침수 되지 않은 건물을 2차원 배열상에 표시해 놓고, 탐색을 시작한다.  
탐색은 침수 되지 않은 건물을 시작으로 표시해 나가고, 상,하,좌,우로 침수되지 않은 건물을 표시한다.  
연결된 구역을 모두 표시하기 때문에, 탐색이 이루어지는 경우만 카운트를 하여, 안전 구역을 카운트 한다.  
  
* 비가 오지 않는 경우를 고려해야 하기 때문에, 비가 오지 않는 경우는 전 구역이 연결되어 '안전 구역'의 갯수는 1 이다.
~~~

분류
* DFS
* BFS

***

## StringRepeat (문자열 반복)
https://www.acmicpc.net/problem/2675

문제 요약
> 숫자와 문자열을 나란히 입력 받는다. 입력 받은 숫자 만큼, 문자열의 각 문자를 반복해서 출력한다.
>> ex, '3 ABC' -> 'AAABBBCCC'

풀이
~~~
그대로 구현하면 된다.
~~~

분류
* 구현