### Change (거스름 돈)
https://www.acmicpc.net/problem/5585

문제 요약
> 거스름 돈을 동전으로만 주어야 할 때, 동전의 갯수가 최소가 되도록 하라.
>> 1.  동전은 '500', '100', '50', '10', '5', '1' 원 단위.  
>> 2.  동전의 갯수는 무한히 많다.

풀이
~~~
동전의 갯수만 구하면 된다.
1. 가장 큰 동전으로 나눠 보고 나눠지는 나머지를 계속해서 동전으로 나눠 준다.
2. '1원' 단위 까지 있기 때문에 무조건 나누어 떨어진다.
~~~

유형  
* 그리디 알고리즘
* 기하 알고리즘
* 구현

---
### CompititionOrIntern (대회 or 인턴)
https://www.acmicpc.net/problem/2875

문제 요약
> 대회에 나가는 인원과 인턴을 나가는 인원을 적절하게 분배해야 한다.
>> 1. 대회는 팀을 이뤄 나가는데 여성 2명, 남성 1명이 한 팀이다.  
>> 2. 인턴을 나가는 인원 수가 주어지고, 총 인원에서 무조건 인턴 수 만큼은 빠져야 한다.  
>> 3. 한 줄에 '6 3 2' -> '여성 남성 인턴' 으로 주어진다.

풀이
~~~
팀을 이루는 수 만큼 씩 각 성별에서 빼주면서 팀의 갯수를 카운트 한다.
  
1. 팀을 이루기 위해서 여성 최소 2명 + 남성 최소 1명이 필요하다.
2. 남은 사람의 수는 인턴의 수 보다 작으면 안된다.
~~~

유형
* 그리디 알고리즘

---
### KnightMove (나이트의 이동)
https://www.acmicpc.net/problem/7562

문제 요약
> 체스 말 중, '나이트(Knight)'를 이동시켜 목표 지점 까지 몇번 만에 가는지 확인하라.
>> 1. '나이트'는 좌표상에 대각 방향으로 이동하고 총 8 방향으로 이동 가능하다.
>> 2. 테스트케이스 수가 주어지고, 테스트 케이스 마다 말의 위치와, 판이 바뀐다.

풀이
~~~
BFS 문제로 접근
1. 총 여덟 방향으로의 움직임을 고려한다.
2. 이동 한 위치에서 부터 각각 움직임 달라진다.
3. 각 위치 마다의 Count 를 진행해야 하기 때문에, Queue 에 쌓은 말의 위치 만큼 돌면서 Count 한다.
~~~

유형
* BFS

---
### MinimumValues (최솟값) / ~~FAIL, 시간초과~~
https://www.acmicpc.net/problem/10868

* String[] to Integer[]
~~~
String[] strArr = {"123", "456", "789"};
~~~


_java 8, 이전_
~~~
for(int i=0; i<strArr.length; i++) {
    intArr[i] = Integer.parseInt(strArr[i]);
}
~~~


_java 8, stream_
~~~
Integer[] intArr = Arrays.asList(strArr).stream().mapToInt(Integer::parseInt).toArray();
~~~

---
### Tomato (토마토)
https://www.acmicpc.net/problem/7576

문제 요약
> 박스 안에 익은 토마토와 안 익은 토마토가 있다. 박스 안에 토마토가 전부 익으려면 며칠이 걸릴까. 
>> 1. 익은 토마토는 상하좌우로 토마토를 익힌다.
>> 2. 토마토가 없을 수도 있다.
>> 3. 토마토가 익는데는 하루가 걸린다.
>> 4. 익은 토마토는 여러군데 있을 수 있다.

풀이
~~~
BFS 문제로 접근한다. 토마토 상하좌우로 익은 토마토를 체크해 나아간다.
  
1. 익은 토마토를 찾는다.
2. 익은 토마토를 Queue 에 넣는다.
3. 익은 토마토가 여러개 일 경우, 동시에 익어야 하기 때문에 익은 토마토가 들어있는 Queue size 만큼 상하좌우를 익혀 나간다.
4. (BFS) 토마토가 있을 경우 익히고, 익힌 토마토 일 경우 넘어간다. -> 익힌 토마토를 표시할 '임시 BOX' 가 필요.
5. 안 익은 토마토의 갯수와 BFS 로 익힌 토마토의 갯수를 파악해 가며 조건을 준다.  
~~~

유형
* BFS